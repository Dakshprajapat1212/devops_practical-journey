# Core Ansible Modules Commonly Used in DevOps

Below is a categorized, near-comprehensive list of the Ansible modules you’ll reach for again and again when automating DevOps workflows.  

---

## 1. Package Management  
- **apt**: Install, remove or update .deb packages on Debian/Ubuntu.  
- **yum**: Manage RPM packages on CentOS/RedHat.  
- **dnf**: Fedora’s next-gen package manager.  
- **pip**: Install Python packages from PyPI.  
- **npm**: Install Node.js packages.  
- **gem**: Manage Ruby gems.  

---

## 2. Service & Process Control  
- **service**: Start, stop, restart SysV services.  
- **systemd**: Same as `service` but for systemd-based distros (e.g., `systemctl`).  
- **supervisorctl**: Control processes managed by Supervisor.  

---

## 3. File, Directory & Template Management  
- **copy**: Copy a file from controller to target.  
- **template**: Jinja2-rendered files from controller to target.  
- **file**: Set permissions, ownership, symlinks.  
- **lineinfile**: Ensure a particular line is in a file.  
- **blockinfile**: Manage multi-line text blocks.  
- **replace**: Regex-based search/replace.  
- **synchronize**: Wrapper around rsync.  
- **unarchive**: Unpack .tar/.zip archives.  

---

## 4. Command & Shell Execution  
- **command**: Run a command (no shell features).  
- **shell**: Run via `/bin/sh` (supports pipes, redirects).  
- **raw**: Run a command without any module dependencies (good for bootstrapping).  

---

## 5. User, Group & SSH Key Management  
- **user**: Create, modify, remove user accounts.  
- **group**: Manage Unix groups.  
- **authorized_key**: Add or remove SSH public keys.  
- **ssh_key**: Generate SSH key pairs.  

---

## 6. Version Control & SCM  
- **git**: Clone, fetch or pull Git repositories.  
- **svn**: Checkout or update Subversion repositories.  
- **hg**: Mercurial repo operations.  

---

## 7. Networking & HTTP APIs  
- **uri**: Interact with HTTP/REST APIs (GET, POST, etc.).  
- **get_url**: Download files via HTTP/FTP.  
- **uri_facts**: Gather headers and status codes.  

---

## 8. Cloud & Infrastructure Provisioning  
- **ec2**: Launch, terminate AWS EC2 instances.  
- **cloudformation**: Deploy AWS CloudFormation stacks.  
- **azure_rm**: Manage Azure resources.  
- **gcp_compute**: Create/delete GCP VMs.  
- **openstack**: Interact with OpenStack services.  

---

## 9. Container & Orchestration  
- **docker_image**: Build or pull Docker images.  
- **docker_container**: Run, stop, remove Docker containers.  
- **k8s** / **k8s_facts**: Deploy to and gather info from Kubernetes.  
- **podman_container**: Manage Podman containers.  

---

## 10. Database Management  
- **mysql_db**, **mysql_user**: Create databases and users in MySQL/MariaDB.  
- **postgresql_db**, **postgresql_user**: PostgreSQL equivalents.  
- **mongodb_user**, **mongodb_replicaset**: MongoDB control.  

---

## 11. Monitoring & Notifications  
- **nagios** / **icinga2**: Update service checks.  
- **slack**: Send messages to Slack.  
- **mail**: Send email alerts.  
- **pagerduty**: Trigger PagerDuty incidents.  

---

## 12. Utility & Control Flow  
- **debug**: Print variables or messages.  
- **assert**: Fail a play if a condition isn’t met.  
- **pause**: Stop execution for a prompt or time.  
- **wait_for**: Wait for a port, file, or condition.  
- **include_role** / **import_role**: Bring in reusable roles.  
- **block**: Group tasks and apply common error handling.  
- **meta**: Control playbook lifecycle (e.g., `flush_handlers`, `end_play`).  

---

## 13. Packaging & Release  
- **rpm_key**: Manage RPM signing keys.  
- **npm_key**: Manage npm authentication.  
- **archive**: Create tar/zip archives on target.  

---

# Bringing It All Together

You don’t need every one of these modules in every playbook. In a typical DevOps pipeline, you might:

1. Provision infrastructure with `ec2` or Terraform (outside Ansible).  
2. Configure OS with `apt`/`yum`, `user`, `group`.  
3. Deploy apps via `git`, `copy`, `template`.  
4. Install dependencies with `pip` or `npm`.  
5. Manage services via `systemd` / `service`.  
6. Boot containers with `docker_container`.  
7. Configure Kubernetes via `k8s`.  
8. Hook into monitoring with `uri`, `slack`, `mail`.  

Each of these modules encapsulates a slice of system knowledge—no shell-embedding required. Mix and match them to automate your entire build-deploy-monitor cycle.  

Want more?  
- Dive into the [Ansible module index](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/index.html).  
- Explore community-contributed modules on [Ansible Galaxy](https://galaxy.ansible.com/).  
- Start crafting **roles** to group related tasks, variables, templates, and handlers into reusable units.  


Here’s a single Ansible playbook skeleton illustrating one task per major DevOps module category—pure YAML so you can grab, tweak and drop into your own repos:

```yaml
---
- name: DevOps “Toolbox” Demo Playbook
  hosts: all
  become: yes

  tasks:

    # 1. Package Management
    - name: Install Nginx on Debian/Ubuntu
      apt:
        name: nginx
        state: present

    - name: Install Git on CentOS/RedHat
      yum:
        name: git
        state: present

    - name: Install Python requests via pip
      pip:
        name: requests
        state: present

    - name: Install lodash via npm
      npm:
        name: lodash
        global: yes

    - name: Install rails gem
      gem:
        name: rails
        state: present

    # 2. Service & Process Control
    - name: Ensure Nginx is running
      service:
        name: nginx
        state: started

    - name: Restart a systemd service
      systemd:
        name: docker
        state: restarted

    # 3. File, Directory & Template Management
    - name: Copy a static config file
      copy:
        src: files/app.conf
        dest: /etc/myapp/app.conf
        owner: root
        mode: '0644'

    - name: Deploy an Nginx vhost from template
      template:
        src: templates/vhost.j2
        dest: /etc/nginx/sites-available/demo.conf

    # 4. Command & Shell Execution
    - name: Run a simple shell command
      shell: echo "Hello from {{ inventory_hostname }}"

    - name: Bootstrap with raw when no Python present
      raw: yum install -y python3

    # 5. User, Group & SSH Key Management
    - name: Create deploy user
      user:
        name: deploy
        groups: sudo
        shell: /bin/bash

    - name: Add SSH key for deploy user
      authorized_key:
        user: deploy
        key: "{{ lookup('file', 'keys/deploy.pub') }}"

    # 6. Version Control & SCM
    - name: Checkout app repo from GitHub
      git:
        repo: 'https://github.com/you/your-app.git'
        dest: /opt/your-app
        version: main

    # 7. Networking & HTTP APIs
    - name: Download release artifact
      get_url:
        url: https://example.com/artifact.tar.gz
        dest: /tmp/artifact.tar.gz

    - name: Call health-check API
      uri:
        url: http://localhost:8080/health
        method: GET
        status_code: 200

    # 8. Cloud & Infrastructure Provisioning
    - name: Launch an EC2 instance (AWS)
      ec2:
        key_name: mykey
        instance_type: t2.micro
        image: ami-0abcdef1234567890
        wait: yes
        region: us-east-1

    # 9. Container & Orchestration
    - name: Pull and run a Docker container
      docker_container:
        name: myapp
        image: nginx:latest
        state: started
        ports:
          - "80:80"

    # 10. Database Management
    - name: Create MySQL database
      mysql_db:
        name: myappdb
        state: present

    # 11. Monitoring & Notifications
    - name: Send deployment notification to Slack
      slack:
        token: "{{ slack_token }}"
        msg: "Deployment complete on {{ inventory_hostname }}"
        channel: "#deployments"

    # 12. Utility & Control Flow
    - name: Print debug info
      debug:
        msg: "All tasks so far succeeded"

    - name: Assert that a variable is defined
      assert:
        that:
          - inventory_hostname is defined

    - name: Pause for 10 seconds
      pause:
        seconds: 10

    - name: Wait for web port to become available
      wait_for:
        host: 127.0.0.1
        port: 80
        timeout: 300

    - name: Include role for common security hardening
      include_role:
        name: security-hardening

    - name: Run maintenance block with error handling
      block:
        - name: Backup DB
          shell: /usr/local/bin/backup-db.sh
        - name: Rotate application logs
          shell: /usr/local/bin/rotate-logs.sh
      rescue:
        - debug:
            msg: "Maintenance failed, check logs!"

    - name: End play and flush any handlers
      meta: flush_handlers
```

— —

Want to turn this skeleton into production-grade roles or split it into environment-specific playbooks? Let me know and I’ll show you how to modularize and DRY-up your Ansible code.
With this “toolbox” of modules at your fingertips, you can confidently automate almost anything your DevOps workflow demands.
