
      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      Here's a detailed breakdown and documentation of the `terraform plan` output you've shared, explaining each part of the execution plan and its significance:
terraform apply

Terraform used the selected providers to generate the following
execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.app_server will be created
  + resource "aws_instance" "app_server" {
      + ami                                  = "ami-830c94e3"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = (known after apply)
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "Terraform_Demo"
        }
      + tags_all                             = {
          + "Name" = "Terraform_Demo"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.app_server: Creating...
aws_instance.app_server: Still creating... [00m10s elapsed]
aws_instance.app_server: Still creating... [00m20s elapsed]
aws_instance.app_server: Still creating... [00m30s elapsed]
aws_instance.app_server: Still creating... [00m40s elapsed]
aws_instance.app_server: Still creating... [00m50s elapsed]
aws_instance.app_server: Still creating... [01m00s elapsed]
aws_instance.app_server: Creation complete after 1m2s [id=i-08350ea5ed0838333]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
ubuntu@ip-172-31-38-189:~/terraform$ cat main.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }

  required_version = ">= 1.2.0"
}

provider "aws" {
  region  = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "Terraform_Demo"
  }
}
ubuntu@ip-172-31-38-189:~/terraform$
---

## 📘 Terraform Plan Overview

The `terraform plan` command is used to preview the changes Terraform will make to your infrastructure. It compares your current configuration with the existing state and shows what actions will be taken—without actually applying them.

In your case, Terraform is planning to **create** one resource: an AWS EC2 instance.

---

## 🏗️ Resource to Be Created

### `aws_instance.app_server`

This block defines an EC2 instance named `app_server`. Here's what each attribute means:

| Attribute | Description |
|----------|-------------|
| `ami = "ami-830c94e3"` | Specifies the Amazon Machine Image (AMI) ID used to launch the instance. |
| `instance_type = "t2.micro"` | Defines the instance type. `t2.micro` is a low-cost, burstable performance instance. |
| `tags = { "Name" = "Terraform_Demo" }` | Adds a tag to the instance for identification. |
| `source_dest_check = true` | Enables source/destination checks (default for EC2). |
| `get_password_data = false` | Disables retrieval of Windows password data (irrelevant for Linux AMIs). |
| `user_data_replace_on_change = false` | Prevents replacement of the instance if `user_data` changes. |

### Attributes marked `(known after apply)`

These are values that Terraform cannot determine until the resource is actually created. Examples include:

- `arn`, `id`, `public_ip`, `private_ip`
- `availability_zone`, `security_groups`, `subnet_id`
- `metadata_options`, `root_block_device`, etc.

These will be populated once the instance is provisioned.

---

## ✅ Execution Summary

- **Plan:** 1 to add, 0 to change, 0 to destroy
- This means Terraform will create one new resource and make no changes or deletions to existing infrastructure.

---

## ⚠️ Important Note

> You didn't use the `-out` option to save this plan, so Terraform can't guarantee to take exactly these actions if you run `terraform apply`.

This means the plan is speculative. If the infrastructure changes between now and when you run `terraform apply`, the actual actions may differ.

To save the plan for later use:

```bash
terraform plan -out=tfplan
terraform apply tfplan
```

---

WSure! Here's a simple explanation for why your Terraform plan is called **speculative**:

---

### 🧪 What Does "Speculative" Mean in Terraform?

When you run:

```bash
terraform plan
```

Terraform shows you what it *thinks* it will do—like creating a server, changing a setting, or deleting something. But it’s just a **preview**, not a promise.

If you don’t save this plan using:

```bash
terraform plan -out=tfplan
```

then later, when you run:

```bash
terraform apply
```

Terraform will **re-check everything** and might come up with a slightly different plan. That’s why the first plan is called **speculative**—it’s not locked in.

---

### 🔒 How to Make It Exact

If you want Terraform to do **exactly** what it showed in the plan, save it like this:

```bash
terraform plan -out=tfplan
terraform apply tfplan
```

This way, Terraform won’t change its mind later.

---terraform plan

Absolutely! Here's a clear and beginner-friendly documentation for your Terraform setup and execution process, based on what you've shared:

---

## 📄 Terraform EC2 Instance Deployment — Documentation

This guide explains how Terraform was used to deploy an AWS EC2 instance using a simple configuration.

---

### 🛠️ Files and Configuration

#### `main.tf`

This file contains the Terraform configuration for deploying an EC2 instance.

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }
  required_version = ">= 1.2.0"
}

provider "aws" {
  region = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "Terraform_Demo"
  }
}
```

---

### ⚙️ Steps Performed

#### 1. **Initialize Terraform**

```bash
terraform init
```

This command sets up the working directory and downloads the required provider plugins.

#### 2. **Preview the Plan**

```bash
terraform plan
```

Terraform shows what it will do—create one EC2 instance. This is a speculative preview unless saved using `-out`.

#### 3. **Apply the Plan**

```bash
terraform apply
```

Terraform prompts for confirmation. After typing `yes`, it proceeds to create the EC2 instance.

---

### ✅ Result

- **Resource Created:** `aws_instance.app_server`
- **Instance Type:** `t2.micro`
- **AMI Used:** `ami-830c94e3`
- **Region:** `us-west-2`
- **Tag:** `Name = Terraform_Demo`
- **Instance ID:** `i-08350ea5ed0838333`
- **Status:** Creation complete in ~1 minute

---

### 📌 Notes

- Attributes like `public_ip`, `private_ip`, `availability_zone`, etc., are marked as `(known after apply)` because AWS assigns them during creation.
- You can view the instance in the AWS EC2 console under the specified region.

---

### 🧹 Next Steps

- To destroy the instance:  
  ```bash
  terraform destroy
  ```

- To add more resources (like security groups, volumes, etc.), expand your `main.tf`.

---

Would you like me to help you add outputs or variables to make this setup more dynamic?
