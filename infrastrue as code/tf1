
      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      Here's a detailed breakdown and documentation of the `terraform plan` output you've shared, explaining each part of the execution plan and its significance:
terraform apply

Terraform used the selected providers to generate the following
execution plan. Resource actions are indicated with the following
symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.app_server will be created
  + resource "aws_instance" "app_server" {
      + ami                                  = "ami-830c94e3"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = (known after apply)
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "Terraform_Demo"
        }
      + tags_all                             = {
          + "Name" = "Terraform_Demo"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.app_server: Creating...
aws_instance.app_server: Still creating... [00m10s elapsed]
aws_instance.app_server: Still creating... [00m20s elapsed]
aws_instance.app_server: Still creating... [00m30s elapsed]
aws_instance.app_server: Still creating... [00m40s elapsed]
aws_instance.app_server: Still creating... [00m50s elapsed]
aws_instance.app_server: Still creating... [01m00s elapsed]
aws_instance.app_server: Creation complete after 1m2s [id=i-08350ea5ed0838333]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
ubuntu@ip-172-31-38-189:~/terraform$ cat main.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }

  required_version = ">= 1.2.0"
}

provider "aws" {
  region  = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "Terraform_Demo"
  }
}
ubuntu@ip-172-31-38-189:~/terraform$
---

## ğŸ“˜ Terraform Plan Overview

The `terraform plan` command is used to preview the changes Terraform will make to your infrastructure. It compares your current configuration with the existing state and shows what actions will be takenâ€”without actually applying them.

In your case, Terraform is planning to **create** one resource: an AWS EC2 instance.

---

## ğŸ—ï¸ Resource to Be Created

### `aws_instance.app_server`

This block defines an EC2 instance named `app_server`. Here's what each attribute means:

| Attribute | Description |
|----------|-------------|
| `ami = "ami-830c94e3"` | Specifies the Amazon Machine Image (AMI) ID used to launch the instance. |
| `instance_type = "t2.micro"` | Defines the instance type. `t2.micro` is a low-cost, burstable performance instance. |
| `tags = { "Name" = "Terraform_Demo" }` | Adds a tag to the instance for identification. |
| `source_dest_check = true` | Enables source/destination checks (default for EC2). |
| `get_password_data = false` | Disables retrieval of Windows password data (irrelevant for Linux AMIs). |
| `user_data_replace_on_change = false` | Prevents replacement of the instance if `user_data` changes. |

### Attributes marked `(known after apply)`

These are values that Terraform cannot determine until the resource is actually created. Examples include:

- `arn`, `id`, `public_ip`, `private_ip`
- `availability_zone`, `security_groups`, `subnet_id`
- `metadata_options`, `root_block_device`, etc.

These will be populated once the instance is provisioned.

---

## âœ… Execution Summary

- **Plan:** 1 to add, 0 to change, 0 to destroy
- This means Terraform will create one new resource and make no changes or deletions to existing infrastructure.

---

## âš ï¸ Important Note

> You didn't use the `-out` option to save this plan, so Terraform can't guarantee to take exactly these actions if you run `terraform apply`.

This means the plan is speculative. If the infrastructure changes between now and when you run `terraform apply`, the actual actions may differ.

To save the plan for later use:

```bash
terraform plan -out=tfplan
terraform apply tfplan
```

---

WSure! Here's a simple explanation for why your Terraform plan is called **speculative**:

---

### ğŸ§ª What Does "Speculative" Mean in Terraform?

When you run:

```bash
terraform plan
```

Terraform shows you what it *thinks* it will doâ€”like creating a server, changing a setting, or deleting something. But itâ€™s just a **preview**, not a promise.

If you donâ€™t save this plan using:

```bash
terraform plan -out=tfplan
```

then later, when you run:

```bash
terraform apply
```

Terraform will **re-check everything** and might come up with a slightly different plan. Thatâ€™s why the first plan is called **speculative**â€”itâ€™s not locked in.

---

### ğŸ”’ How to Make It Exact

If you want Terraform to do **exactly** what it showed in the plan, save it like this:

```bash
terraform plan -out=tfplan
terraform apply tfplan
```

This way, Terraform wonâ€™t change its mind later.

---terraform plan

Absolutely! Here's a clear and beginner-friendly documentation for your Terraform setup and execution process, based on what you've shared:

---

## ğŸ“„ Terraform EC2 Instance Deployment â€” Documentation

This guide explains how Terraform was used to deploy an AWS EC2 instance using a simple configuration.

---

### ğŸ› ï¸ Files and Configuration

#### `main.tf`

This file contains the Terraform configuration for deploying an EC2 instance.

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }
  required_version = ">= 1.2.0"
}

provider "aws" {
  region = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "Terraform_Demo"
  }
}
```

---

### âš™ï¸ Steps Performed

#### 1. **Initialize Terraform**

```bash
terraform init
```

This command sets up the working directory and downloads the required provider plugins.

#### 2. **Preview the Plan**

```bash
terraform plan
```

Terraform shows what it will doâ€”create one EC2 instance. This is a speculative preview unless saved using `-out`.

#### 3. **Apply the Plan**

```bash
terraform apply
```

Terraform prompts for confirmation. After typing `yes`, it proceeds to create the EC2 instance.

---

### âœ… Result

- **Resource Created:** `aws_instance.app_server`
- **Instance Type:** `t2.micro`
- **AMI Used:** `ami-830c94e3`
- **Region:** `us-west-2`
- **Tag:** `Name = Terraform_Demo`
- **Instance ID:** `i-08350ea5ed0838333`
- **Status:** Creation complete in ~1 minute

---

### ğŸ“Œ Notes

- Attributes like `public_ip`, `private_ip`, `availability_zone`, etc., are marked as `(known after apply)` because AWS assigns them during creation.
- You can view the instance in the AWS EC2 console under the specified region.

---

### ğŸ§¹ Next Steps

- To destroy the instance:  
  ```bash
  terraform destroy
  ```

- To add more resources (like security groups, volumes, etc.), expand your `main.tf`.

---

Would you like me to help you add outputs or variables to make this setup more dynamic?
